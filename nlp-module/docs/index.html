<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Musia ‚Äî Robot Guide 3D (Backend Connected)</title>
    <style>
      /* ==================== ROOT VARIABLES ==================== */
      :root {
        color-scheme: dark;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        --accent: #8fd3ff;
        --bg: #05070d;
        --panel: rgba(6, 10, 18, 0.88);
      }

      /* ==================== BASE STYLES ==================== */
      body {
        margin: 0;
        background: var(--bg);
        overflow: hidden;
      }

      /* ==================== UI PANEL (TOP LEFT) ==================== */
      .ui-panel {
        position: fixed;
        top: 1.5rem;
        left: 1.5rem;
        max-width: 380px;
        padding: 1.4rem 1.7rem;
        border-radius: 1rem;
        background: var(--panel);
        backdrop-filter: blur(16px);
        border: 1px solid rgba(143, 211, 255, 0.3);
        box-shadow: 0 15px 60px rgba(0, 0, 0, 0.6);
        transition: transform 0.3s ease;
        z-index: 100;
      }

      .ui-panel:hover {
        transform: translateY(-2px);
      }

      .ui-panel h1 {
        margin: 0 0 0.6rem;
        font-size: 1.6rem;
        background: linear-gradient(135deg, #8fd3ff, #b8e6ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .ui-panel p {
        margin: 0 0 1.2rem;
        font-size: 0.95rem;
        line-height: 1.5;
        color: #d2e4ff;
      }

      /* ==================== START BUTTON ==================== */
      #startTour {
        appearance: none;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        padding: 0.85rem 1.8rem;
        font-size: 1rem;
        color: #04111e;
        background: linear-gradient(135deg, var(--accent), #b8e6ff);
        cursor: pointer;
        transition: all 0.25s ease;
        box-shadow: 0 12px 30px rgba(143, 211, 255, 0.5);
        width: 100%;
      }

      #startTour:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      #startTour:not(:disabled):hover {
        transform: translateY(-2px) scale(1.02);
        box-shadow: 0 16px 40px rgba(143, 211, 255, 0.65);
      }

      /* ==================== STATUS LINE (BOTTOM LEFT) ==================== */
      #statusLine {
        position: fixed;
        left: 1.5rem;
        bottom: 1.5rem;
        padding: 0.7rem 1.2rem;
        border-radius: 999px;
        background: rgba(6, 10, 18, 0.85);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(143, 211, 255, 0.3);
        font-size: 0.9rem;
        letter-spacing: 0.02em;
        min-width: 280px;
        transition: all 0.3s ease;
        z-index: 100;
        color: #d2e4ff;
      }

      #statusLine.error {
        border-color: rgba(255, 100, 100, 0.5);
        color: #ffb3b3;
      }

      #statusLine.success {
        border-color: rgba(100, 255, 100, 0.5);
        color: #b3ffb3;
      }

      /* ==================== NARRATION BOX (BOTTOM RIGHT) ==================== */
      #narrationBox {
        position: fixed;
        right: 1.5rem;
        bottom: 1.5rem;
        width: min(420px, calc(100vw - 3rem));
        max-height: 70vh;
        overflow-y: auto;
        padding: 1.2rem 1.5rem;
        border-radius: 1rem;
        background: var(--panel);
        backdrop-filter: blur(16px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        opacity: 0;
        transform: translateY(20px);
        transition: all 0.4s ease;
        z-index: 100;
      }

      #narrationBox.active {
        opacity: 1;
        transform: translateY(0);
      }

      #narrationBox h2 {
        margin: 0 0 0.5rem;
        font-size: 1.05rem;
        color: #9ed5ff;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      #narrationText {
        margin: 0 0 1rem;
        font-size: 1rem;
        line-height: 1.5;
        color: #f6fbff;
      }

      /* ==================== CHAT QUESTIONS BUTTONS ==================== */
      #chatQuestions {
        display: none;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid rgba(143, 211, 255, 0.2);
      }

      #chatQuestions.active {
        display: flex;
      }

      .chat-question-btn {
        appearance: none;
        border: 1px solid rgba(143, 211, 255, 0.3);
        border-radius: 0.6rem;
        background: rgba(143, 211, 255, 0.08);
        color: #b8e6ff;
        padding: 0.7rem 1rem;
        font-size: 0.9rem;
        text-align: left;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .chat-question-btn:hover:not(:disabled) {
        background: rgba(143, 211, 255, 0.18);
        border-color: rgba(143, 211, 255, 0.5);
        transform: translateX(4px);
      }

      .chat-question-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      .chat-question-btn.asked {
        opacity: 0.5;
        cursor: default;
      }

      .chat-question-btn.mic-btn {
        background: linear-gradient(135deg, rgba(255, 80, 80, 0.15), rgba(255, 120, 120, 0.15));
        border-color: rgba(255, 100, 100, 0.4);
        font-weight: 600;
      }

      .chat-question-btn.mic-btn:hover:not(:disabled) {
        background: linear-gradient(135deg, rgba(255, 80, 80, 0.25), rgba(255, 120, 120, 0.25));
        border-color: rgba(255, 100, 100, 0.6);
      }

      .chat-question-btn.mic-btn.recording {
        background: linear-gradient(135deg, rgba(255, 50, 50, 0.4), rgba(255, 80, 80, 0.4));
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      /* ==================== VOICE INPUT ==================== */
      #voiceInput {
        margin-top: 0.5rem;
        padding: 0.7rem 1rem;
        border: 1px solid rgba(143, 211, 255, 0.3);
        border-radius: 0.6rem;
        background: rgba(6, 10, 18, 0.6);
        color: #d2e4ff;
        font-size: 0.9rem;
        width: 100%;
        box-sizing: border-box;
      }

      #voiceInput::placeholder {
        color: rgba(210, 228, 255, 0.5);
      }

      /* ==================== RESPONSIVE DESIGN ==================== */
      @media (max-width: 640px) {
        .ui-panel {
          right: 1.5rem;
          max-width: calc(100vw - 3rem);
        }
        #statusLine {
          left: 50%;
          transform: translateX(-50%);
          min-width: auto;
        }
        #narrationBox {
          left: 1.5rem;
          right: 1.5rem;
          bottom: 5.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="ui-panel">
      <h1>Musia ‚Äî Guide Culturel</h1>
      <p>
        D√©couvrez trois tr√©sors de la culture ivoirienne avec votre guide IA. Posez des questions vocales
        ou √©crites sur les peuples Baoul√©, Senoufo et Akan.
      </p>
      <button id="startTour">D√©marrer la visite guid√©e</button>
    </div>

    <div id="statusLine">Musia est pr√™t pour la visite.</div>

    <div id="narrationBox">
      <h2>Narration</h2>
      <p id="narrationText">En attente du lancement de la visite.</p>
      <div id="chatQuestions"></div>
    </div>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

    <script>
      // ============================================================
      // CONFIGURATION BACKEND NLP
      // ============================================================
      const API_BASE_URL = "http://localhost:8000";
      let sessionId = null;
      let currentAudio = null;
      let mediaRecorder = null;
      let audioChunks = [];
      let isRecording = false;

      // ============================================================
      // CONSTANTES GLOBALES
      // ============================================================
      const SPEED_METERS_PER_SECOND = 1.0;

      // TIMEOUT SYSTEM
      let inactivityTimer = null;
      let inactivityInterval = null;
      let inactivityStatusLabel = "";
      let inactivityDeadline = 0;
      const INACTIVITY_TIMEOUT_MS = 15000; // 15 secondes (plus long pour permettre questions)

      // ============================================================
      // API UTILITIES
      // ============================================================

      async function startConversation(artworkId = null) {
        try {
          const response = await fetch(`${API_BASE_URL}/conversation/start`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ artwork_id: artworkId }),
          });

          if (!response.ok) throw new Error("Failed to start conversation");

          const data = await response.json();
          sessionId = data.session_id;
          console.log("‚úÖ Session started:", sessionId);
          return data;
        } catch (error) {
          console.error("‚ùå Failed to start conversation:", error);
          setStatus("‚ö†Ô∏è Connexion au serveur √©chou√©e", "error");
          return null;
        }
      }

      async function askQuestionText(question) {
        if (!sessionId) {
          console.warn("No active session");
          return null;
        }

        try {
          const response = await fetch(`${API_BASE_URL}/conversation/text`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              session_id: sessionId,
              message: question,
            }),
          });

          if (!response.ok) throw new Error("Failed to get response");

          const data = await response.json();
          console.log("‚úÖ AI Response:", data);
          return data;
        } catch (error) {
          console.error("‚ùå Failed to ask question:", error);
          setStatus("‚ö†Ô∏è Erreur de communication", "error");
          return null;
        }
      }

      async function playAudioFromURL(audioUrl) {
        return new Promise((resolve, reject) => {
          if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
          }

          const fullUrl = audioUrl.startsWith("http")
            ? audioUrl
            : `${API_BASE_URL}${audioUrl}`;

          currentAudio = new Audio(fullUrl);

          currentAudio.onended = () => {
            currentAudio = null;
            resolve();
          };

          currentAudio.onerror = (error) => {
            console.error("‚ùå Audio playback error:", error);
            currentAudio = null;
            reject(error);
          };

          currentAudio.play().catch(reject);
        });
      }

      function stopAudio() {
        if (currentAudio) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
          currentAudio = null;
        }
      }

      // ============================================================
      // ARTWORK DATA (Will be enriched with backend data)
      // ============================================================
      const ARTWORKS_DATA = {
        artworks: [
          {
            "id": "masque_goli",
            "title": "Masque I: Le Masque Goli (Baoul√©/B√©t√©k√©)",
            "artist": "Artistes Baoul√© et B√©t√©k√© (C√¥te d'Ivoire)",
            "year": 1950,
            "position": { "x": -7.74, "y": 1.8, "z": -3.5 },
            "rotation": { "y": 90 },
            "colors": { "primary": "#34495e", "accent": "#f39c12" },
            "description": "Le Masque Goli est une succession de quatre masques port√©s lors de danses rituelles importantes. Il se caract√©rise par ses formes circulaires (lune et soleil), ses cornes d'antilope, et sa palette de couleurs vives (noir, rouge, blanc, jaune), symbolisant l'ordre cosmique et l'√©nergie vitale.",
            "stopPosition": { "x": -5.5, "y": 0, "z": -3.5 }
          },
          {
            "id": "masque_senoufo",
            "title": "Masque II: Le Masque Kp√©liy√© (S√©noufo)",
            "artist": "Artistes S√©noufo (C√¥te d'Ivoire, Mali, Burkina Faso)",
            "year": 1965,
            "position": { "x": 0, "y": 1.8, "z": -9.74 },
            "rotation": { "y": 0 },
            "colors": { "primary": "#8b4513", "accent": "#228b22" },
            "description": "Le Kp√©liy√©, ou 'visage-f√©tiche', est le masque S√©noufo par excellence, utilis√© lors des rites d'initiation du Poro. Il se distingue par son visage fin et allong√©, ses projections animales (calaos, phacoch√®res), et ses scarifications g√©om√©triques symbolisant les id√©aux de beaut√© et la sagesse acquise.",
            "stopPosition": { "x": 0, "y": 0, "z": -7.5 }
          },
          {
            "id": "masque_gouro",
            "title": "Masque III: Le Masque Gu (Gouro)",
            "artist": "Artistes Gouro (C√¥te d'Ivoire)",
            "year": 1980,
            "position": { "x": 7.74, "y": 1.8, "z": -3.5 },
            "rotation": { "y": -90 },
            "colors": { "primary": "#e74c3c", "accent": "#bdc3c7" },
            "description": "Le Masque Gouro, souvent appel√© 'Gu', est c√©l√®bre pour l'√©l√©gance de ses traits. Il repr√©sente un visage f√©minin ou une t√™te d'animal stylis√©e (souvent une antilope ou un buffle), avec une coiffure √©labor√©e. Il est utilis√© lors de f√™tes de r√©jouissance ou pour r√©gler des conflits, incarnant la beaut√© et l'autorit√© spirituelle.",
            "stopPosition": { "x": 5.5, "y": 0, "z": -3.5 }
          }
        ],√±j√±kj
      };

      // ============================================================
      // DOM ELEMENTS & NARRATION SYSTEM
      // ============================================================
      const startButton = document.getElementById("startTour");
      const statusLine = document.getElementById("statusLine");
      const narrationBox = document.getElementById("narrationBox");
      const narrationText = document.getElementById("narrationText");
      const chatQuestions = document.getElementById("chatQuestions");

      const setStatus = (text, type = "normal") => {
        statusLine.textContent = text;
        statusLine.className = type === "error" ? "error" : type === "success" ? "success" : "";
      };

      const setNarration = (text, showQuestions = false) => {
        narrationText.textContent = text;
        narrationBox.classList.add("active");

        if (showQuestions) {
          chatQuestions.classList.add("active");
        } else {
          chatQuestions.classList.remove("active");
        }
      };

      const hideNarration = () => {
        narrationBox.classList.remove("active");
        chatQuestions.classList.remove("active");
      };

      async function speak(text, audioUrl, onComplete) {
        clearInactivityTimer();

        if (audioUrl) {
          // Use backend TTS audio
          try {
            await playAudioFromURL(audioUrl);
            onComplete();
          } catch (error) {
            console.error("Audio playback failed, using fallback");
            fallbackSpeak(text, onComplete);
          }
        } else {
          // Fallback to Web Speech API
          fallbackSpeak(text, onComplete);
        }
      }

      function fallbackSpeak(text, onComplete) {
        const speechSupport = "speechSynthesis" in window ? window.speechSynthesis : null;

        if (!speechSupport) {
          const simulatedDuration = Math.max(text.length * 60, 3000);
          setTimeout(onComplete, simulatedDuration);
          return;
        }

        if (speechSupport.speaking) speechSupport.cancel();

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "fr-FR";
        utterance.rate = 0.95;
        utterance.pitch = 1.05;
        utterance.onend = () => onComplete();
        utterance.onerror = () => onComplete();
        speechSupport.speak(utterance);
      }

      // ============================================================
      // INACTIVITY TIMER FUNCTIONS
      // ============================================================
      function startInactivityTimer(baseStatus = "Musia attend vos questions") {
        clearInactivityTimer();
        inactivityStatusLabel = baseStatus;
        inactivityDeadline = performance.now() + INACTIVITY_TIMEOUT_MS;

        function updateCountdown() {
          const remaining = Math.max(0, inactivityDeadline - performance.now());
          const seconds = Math.ceil(remaining / 1000);
          setStatus(`${inactivityStatusLabel} ‚Äî passage auto dans ${seconds}s`);
        }

        updateCountdown();
        inactivityInterval = setInterval(updateCountdown, 250);

        inactivityTimer = setTimeout(() => {
          clearInactivityTimer();
          setStatus("Minuteur expir√©. Reprise automatique...");
          sequenceIndex += 1;
          advanceSequence();
        }, INACTIVITY_TIMEOUT_MS);
      }

      function clearInactivityTimer() {
        if (inactivityTimer) {
          clearTimeout(inactivityTimer);
          inactivityTimer = null;
        }
        if (inactivityInterval) {
          clearInterval(inactivityInterval);
          inactivityInterval = null;
        }
        inactivityDeadline = 0;
      }

      // ============================================================
      // VOICE RECORDING SYSTEM
      // ============================================================
      async function startRecording() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];

          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };

          mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: "audio/wav" });
            await sendAudioQuestion(audioBlob);

            // Stop all tracks
            stream.getTracks().forEach(track => track.stop());
          };

          mediaRecorder.start();
          isRecording = true;
          return true;
        } catch (error) {
          console.error("‚ùå Microphone access denied:", error);
          setStatus("‚ö†Ô∏è Microphone non accessible", "error");
          return false;
        }
      }

      function stopRecording() {
        if (mediaRecorder && isRecording) {
          mediaRecorder.stop();
          isRecording = false;
        }
      }

      async function sendAudioQuestion(audioBlob) {
        if (!sessionId) {
          console.warn("No active session");
          return;
        }

        try {
          setStatus("üé§ Traitement de votre question...");

          const formData = new FormData();
          formData.append("session_id", sessionId);
          formData.append("audio_file", audioBlob, "question.wav");

          const response = await fetch(`${API_BASE_URL}/conversation/ask`, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) throw new Error("Failed to process audio");

          const data = await response.json();
          console.log("‚úÖ Audio response:", data);

          // Display transcription and response
          setNarration(`Vous: "${data.user_input}"\n\nMusia: ${data.response}`, true);

          // Play audio response
          if (data.audio_url) {
            await playAudioFromURL(data.audio_url);
          }

          // Restart inactivity timer
          startInactivityTimer(inactivityStatusLabel || "Musia attend vos questions");
        } catch (error) {
          console.error("‚ùå Failed to process audio:", error);
          setStatus("‚ö†Ô∏è Erreur de traitement audio", "error");
        }
      }

      // ============================================================
      // CHAT SYSTEM - QUESTION HANDLING
      // ============================================================
      let currentArtwork = null;

      function displayChatQuestions(artwork) {
        chatQuestions.innerHTML = "";
        currentArtwork = artwork;

        // Add AI-powered text input
        const textInput = document.createElement("input");
        textInput.type = "text";
        textInput.id = "voiceInput";
        textInput.placeholder = "Posez une question sur l'≈ìuvre...";
        textInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && textInput.value.trim()) {
            handleTextQuestion(textInput.value.trim());
            textInput.value = "";
          }
        });
        chatQuestions.appendChild(textInput);

        // Add microphone button
        const micBtn = document.createElement("button");
        micBtn.className = "chat-question-btn mic-btn";
        micBtn.textContent = "üé§ Poser une question vocale";
        micBtn.addEventListener("mousedown", async () => {
          if (!isRecording) {
            const started = await startRecording();
            if (started) {
              micBtn.textContent = "üî¥ Enregistrement... (rel√¢chez pour envoyer)";
              micBtn.classList.add("recording");
            }
          }
        });
        micBtn.addEventListener("mouseup", () => {
          if (isRecording) {
            stopRecording();
            micBtn.textContent = "üé§ Poser une question vocale";
            micBtn.classList.remove("recording");
          }
        });
        chatQuestions.appendChild(micBtn);

        // Add continue button
        const continueBtn = createContinueButton();
        chatQuestions.appendChild(continueBtn);
      }

      async function handleTextQuestion(question) {
        clearInactivityTimer();
        setStatus("üí≠ Traitement de votre question...");

        const response = await askQuestionText(question);

        if (response) {
          setNarration(`Vous: "${question}"\n\nMusia: ${response.response}`, true);

          if (response.audio_url) {
            await playAudioFromURL(response.audio_url);
          } else {
            await new Promise(resolve => {
              fallbackSpeak(response.response, resolve);
            });
          }
        }

        startInactivityTimer(inactivityStatusLabel || "Musia attend vos questions");
      }

      // ============================================================
      // THREE.JS - SCENE SETUP
      // ============================================================
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05070d);
      scene.fog = new THREE.Fog(0x05070d, 16, 38);

      // CAMERA SETUP
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(8, 7, 14);
      camera.lookAt(0, 1, -4);

      // RENDERER SETUP
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // LIGHTING
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(8, 12, 6);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.near = 0.5;
      dirLight.shadow.camera.far = 30;
      dirLight.shadow.camera.left = -15;
      dirLight.shadow.camera.right = 15;
      dirLight.shadow.camera.top = 15;
      dirLight.shadow.camera.bottom = -15;
      scene.add(dirLight);

      ARTWORKS_DATA.artworks.forEach((art) => {
        const spotLight = new THREE.SpotLight(art.colors.primary, 0.6);
        spotLight.position.set(
          art.position.x * 0.7,
          3.5,
          art.position.z * 0.7 + 1
        );
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.5;
        spotLight.decay = 2;
        spotLight.distance = 10;
        scene.add(spotLight);
      });

      // FLOOR & GRID
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshStandardMaterial({
          color: 0x0d1421,
          roughness: 0.9,
          metalness: 0.1,
        })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      const grid = new THREE.GridHelper(28, 28, 0x2f4d73, 0x1a2a3f);
      grid.position.y = 0.01;
      scene.add(grid);

      // WALLS
      function createWall(x, z, rotationY, color, length, depth = 0.5) {
        const wall = new THREE.Mesh(
          new THREE.BoxGeometry(length, 5, depth),
          new THREE.MeshStandardMaterial({
            color,
            roughness: 0.7,
            metalness: 0.05,
          })
        );
        wall.position.set(x, 2.5, z);
        wall.rotation.y = rotationY;
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);
        return wall;
      }

      function buildMuseumRoom() {
        createWall(0, -10, 0, 0x1c2735, 16);
        createWall(-8, -5, Math.PI / 2, 0x1c2735, 10);
        createWall(8, -5, -Math.PI / 2, 0x212a33, 10);
      }
      buildMuseumRoom();

      // ARTWORK TEXTURE GENERATOR
      function createArtworkTexture(primary, accent, label) {
        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext("2d");

        const grad = ctx.createLinearGradient(0, 0, size, size);
        grad.addColorStop(0, primary);
        grad.addColorStop(0.5, accent);
        grad.addColorStop(1, primary);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, size);

        ctx.fillStyle = "rgba(255,255,255,0.12)";
        for (let i = 0; i < 8; i++) {
          ctx.fillRect(i * 64, 0, 16, size);
        }

        ctx.fillStyle = "rgba(255,255,255,0.08)";
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.arc(
            Math.random() * size,
            Math.random() * size,
            20 + Math.random() * 40,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        ctx.fillStyle = "#fefefe";
        ctx.font = "bold 42px 'Segoe UI'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 8;
        ctx.fillText(label, size / 2, size / 2);

        return new THREE.CanvasTexture(canvas);
      }

      // ARTWORK FRAME BUILDER
      function createArtFrame(artData) {
        const frame = new THREE.Group();

        const border = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 1.9, 0.1),
          new THREE.MeshStandardMaterial({
            color: 0x3e2815,
            metalness: 0.3,
            roughness: 0.6,
          })
        );
        border.castShadow = true;

        const artwork = new THREE.Mesh(
          new THREE.PlaneGeometry(2.2, 1.6),
          new THREE.MeshStandardMaterial({
            map: createArtworkTexture(
              artData.colors.primary,
              artData.colors.accent,
              artData.title.split(":")[0]
            ),
          })
        );
        artwork.position.z = 0.055;

        frame.add(border, artwork);
        frame.position.set(
          artData.position.x,
          artData.position.y,
          artData.position.z
        );
        frame.rotation.y = (artData.rotation.y * Math.PI) / 180;
        scene.add(frame);

        return frame;
      }

      const artworkFrames = ARTWORKS_DATA.artworks.map(createArtFrame);

      // ROBOT MUSIA - CONSTRUCTOR
      function buildMusia() {
        const group = new THREE.Group();

        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.62, 1.2, 32),
          new THREE.MeshStandardMaterial({
            color: 0x8fd3ff,
            metalness: 0.5,
            roughness: 0.3,
          })
        );
        body.position.y = 0.65;
        body.castShadow = true;

        const headGroup = new THREE.Group();
        headGroup.position.y = 1.5;
        headGroup.name = "headGroup";

        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 28, 20),
          new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.2,
            roughness: 0.4,
          })
        );
        head.castShadow = true;

        const visor = new THREE.Mesh(
          new THREE.CylinderGeometry(0.32, 0.32, 0.16, 32, 1, true),
          new THREE.MeshStandardMaterial({
            color: 0x0a1628,
            emissive: 0x1565c0,
            emissiveIntensity: 0.8,
            side: THREE.DoubleSide,
          })
        );
        visor.rotation.x = Math.PI / 2;
        visor.position.set(0, -0.08, -0.22);

        headGroup.add(head, visor);

        const frontArrow = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.25, 1),
          new THREE.MeshStandardMaterial({
            color: 0xfff9c4,
            emissive: 0x9e7e22,
            emissiveIntensity: 0.4,
          })
        );
        frontArrow.position.set(0, 0.28, -0.5);

        const wheelGroup = new THREE.Group();
        wheelGroup.position.y = 0.18;
        wheelGroup.name = "wheelGroup";

        const wheel = new THREE.Mesh(
          new THREE.CylinderGeometry(0.38, 0.38, 0.28, 40),
          new THREE.MeshStandardMaterial({
            color: 0x0d0d0d,
            metalness: 0.1,
            roughness: 0.8,
          })
        );
        wheel.rotation.z = Math.PI / 2;
        wheel.castShadow = true;
        wheelGroup.add(wheel);

        group.add(body, headGroup, frontArrow, wheelGroup);
        group.name = "Musia";
        return group;
      }

      const musia = buildMusia();
      musia.castShadow = true;
      scene.add(musia);

      // ============================================================
      // PATH TRAJECTORY - WAYPOINTS
      // ============================================================
      const START = new THREE.Vector3(0, 0, 0);

      const pathPoints = [
        START.clone(),
        new THREE.Vector3(-3.5, 0, -1.8),
        new THREE.Vector3(
          ARTWORKS_DATA.artworks[0].stopPosition.x,
          0,
          ARTWORKS_DATA.artworks[0].stopPosition.z
        ),
        new THREE.Vector3(-1.8, 0, -6),
        new THREE.Vector3(
          ARTWORKS_DATA.artworks[1].stopPosition.x,
          0,
          ARTWORKS_DATA.artworks[1].stopPosition.z
        ),
        new THREE.Vector3(1.8, 0, -6),
        new THREE.Vector3(
          ARTWORKS_DATA.artworks[2].stopPosition.x,
          0,
          ARTWORKS_DATA.artworks[2].stopPosition.z
        ),
        new THREE.Vector3(3.5, 0, -1.8),
        START.clone(),
      ];

      // PATH TRAJECTORY - CATMULL-ROM SPLINE
      const visitCurve = new THREE.CatmullRomCurve3(
        pathPoints,
        false,
        "centripetal"
      );

      const curveGeometry = new THREE.BufferGeometry().setFromPoints(
        visitCurve.getPoints(300)
      );
      const curveLine = new THREE.Line(
        curveGeometry,
        new THREE.LineDashedMaterial({
          color: 0x5bb5ee,
          dashSize: 0.5,
          gapSize: 0.25,
          linewidth: 2,
        })
      );
      curveLine.computeLineDistances();
      curveLine.position.y = 0.03;
      scene.add(curveLine);

      // PATH TRAJECTORY - POSITION FINDER
      function findParamForPosition(target) {
        const divisions = 1000;
        let closestU = 0;
        let min = Infinity;
        const target2D = new THREE.Vector2(target.x, target.z);

        for (let i = 0; i <= divisions; i++) {
          const u = i / divisions;
          const point = visitCurve.getPointAt(u);
          const point2D = new THREE.Vector2(point.x, point.z);
          const dist = point2D.distanceToSquared(target2D);
          if (dist < min) {
            min = dist;
            closestU = u;
          }
        }
        return closestU;
      }

      // ============================================================
      // TOUR STOPS - BUILD FROM JSON DATA
      // ============================================================
      const stops = [
        {
          id: "start",
          label: "Point central",
          position: START,
          narration: "Bienvenue au mus√©e. Je suis Musia, votre guide autonome pour cette visite immersive de trois ≈ìuvres majeures de l'histoire de l'art.",
          u: 0,
        },
      ];

      ARTWORKS_DATA.artworks.forEach((art) => {
        const stopPos = new THREE.Vector3(
          art.stopPosition.x,
          art.stopPosition.y,
          art.stopPosition.z
        );
        stops.push({
          id: art.id,
          label: art.title,
          position: stopPos,
          focus: new THREE.Vector3(
            art.position.x,
            art.position.y - 0.3,
            art.position.z
          ),
          u: findParamForPosition(stopPos),
          narration: art.description,
          artwork: art,
        });
      });

      const returnPos = START.clone();
      returnPos.x = -0.01;
      stops.push({
        id: "return",
        label: "Retour",
        position: START,
        u: findParamForPosition(START) || 1,
        narration: "Merci d'avoir suivi cette visite guid√©e des grands classiques. Musia se tient pr√™t pour approfondir chaque collection lors de votre prochaine venue.",
      });

      // PATH CONTROL - UTILITIES
      const curveLengthCache = {};

      function getSegmentLength(startU, endU) {
        const cacheKey = `${startU}-${endU}`;
        if (curveLengthCache[cacheKey]) return curveLengthCache[cacheKey];

        const divisions = 100;
        let length = 0;
        let previousPoint = visitCurve.getPointAt(startU);
        const uRange = endU - startU;

        for (let i = 1; i <= divisions; i++) {
          const currentU = startU + (uRange * i) / divisions;
          const currentPoint = visitCurve.getPointAt(currentU);
          length += previousPoint.distanceTo(currentPoint);
          previousPoint = currentPoint;
        }

        curveLengthCache[cacheKey] = length;
        return length;
      }

      // SEQUENCE BUILDER - DYNAMIC FROM STOPS
      const sequence = [];
      for (let i = 0; i < stops.length - 1; i++) {
        const fromStop = stops[i];
        const toStop = stops[i + 1];

        const segmentLength = getSegmentLength(fromStop.u, toStop.u);
        const moveDuration = segmentLength / SPEED_METERS_PER_SECOND;

        sequence.push({
          type: "MOVE",
          from: fromStop,
          to: toStop,
          label: `Musia se dirige vers ${toStop.label} (${segmentLength.toFixed(1)}m)`,
          state: i === stops.length - 2 ? "RETURNING" : "MOVING",
          duration: moveDuration,
        });

        sequence.push({
          type: "NARRATE",
          stop: toStop,
          label: `Pr√©sentation: ${toStop.label}`,
        });
      }

      // STATE MACHINE - TOUR STATES
      const State = {
        IDLE: "IDLE",
        MOVING: "MOVING",
        NARRATING: "NARRATING",
        RETURNING: "RETURNING",
      };

      let currentState = State.IDLE;
      let sequenceIndex = 0;
      let activeMove = null;
      let uProgress = 0;
      let focusTarget = null;

      const baseForward = new THREE.Vector3(0, 0, -1);
      const tmpQuaternion = new THREE.Quaternion();
      const headGroup = musia.getObjectByName("headGroup");
      const wheelGroup = musia.getObjectByName("wheelGroup");

      // ROBOT ANIMATION - POSE SETTER
      function setRobotPose(u, animate = true) {
        const point = visitCurve.getPointAt(u);
        const tangent = visitCurve.getTangentAt(u).normalize();

        musia.position.set(point.x, 0, point.z);
        tmpQuaternion.setFromUnitVectors(baseForward, tangent);

        if (animate) {
          musia.quaternion.slerp(tmpQuaternion, 0.15);
        } else {
          musia.quaternion.copy(tmpQuaternion);
        }

        if (currentState === State.MOVING || currentState === State.RETURNING) {
          wheelGroup.rotation.x += (SPEED_METERS_PER_SECOND / 0.38) * 0.005;
        }
      }

      // CAMERA SYSTEM - DYNAMIC FOLLOWING
      const cameraTarget = new THREE.Vector3();
      const cameraOffset = new THREE.Vector3(4, 5, 8);

      function updateCamera() {
        const targetPos = musia.position.clone();

        if (focusTarget && currentState === State.NARRATING) {
          const midPoint = targetPos.clone().lerp(focusTarget, 0.6);
          cameraTarget.lerp(midPoint, 0.05);

          const lookTarget = focusTarget.clone();
          lookTarget.y += 0.5;
          camera.lookAt(lookTarget);

          headGroup.lookAt(focusTarget);
          headGroup.rotation.x = 0;
        } else {
          targetPos.y = 1;
          cameraTarget.lerp(targetPos, 0.08);
          camera.lookAt(cameraTarget);
          headGroup.rotation.set(0, 0, 0);
        }

        const desiredPos = targetPos.clone().add(cameraOffset);
        camera.position.lerp(desiredPos, 0.06);
      }

      // SEQUENCE CONTROL - MOVE LAUNCHER
      function launchMove(segment) {
        clearInactivityTimer();
        activeMove = {
          startU: segment.from.u,
          endU: segment.to.u,
          direction: segment.to.u > segment.from.u ? 1 : -1,
          label: segment.label,
          duration: segment.duration,
          timeElapsed: 0,
        };
        currentState = segment.state;
        setStatus(segment.label);
        hideNarration();
        focusTarget = null;
      }

      // SEQUENCE CONTROL - NARRATION LAUNCHER
      let narrationCompleted = false;

      async function launchNarration(segment) {
        currentState = State.NARRATING;
        setStatus(segment.label);
        focusTarget = segment.stop.focus || new THREE.Vector3(0, 1, -5);
        narrationCompleted = false;

        const hasInteraction = segment.stop.artwork !== undefined;
        setNarration(segment.stop.narration, hasInteraction);

        if (hasInteraction) {
          displayChatQuestions(segment.stop.artwork);

          // Start conversation session for this artwork
          await startConversation(segment.stop.artwork.id);
        }

        // Use backend TTS if available
        let audioUrl = null;
        // For now, use fallback speech synthesis
        // TODO: Fetch narrative with TTS from backend

        speak(segment.stop.narration, audioUrl, () => {
          narrationCompleted = true;
          if (hasInteraction) {
            startInactivityTimer(segment.label);
          } else {
            sequenceIndex += 1;
            setTimeout(() => advanceSequence(), 800);
          }
        });
      }

      // SEQUENCE CONTROL - CONTINUE BUTTON
      function createContinueButton() {
        const btn = document.createElement("button");
        btn.id = "continueBtn";
        btn.className = "chat-question-btn";
        btn.textContent = "‚Üí Continuer la visite";
        btn.style.marginTop = "0.5rem";
        btn.style.background = "linear-gradient(135deg, rgba(143, 211, 255, 0.2), rgba(184, 230, 255, 0.2))";
        btn.style.borderColor = "rgba(143, 211, 255, 0.5)";
        btn.style.fontWeight = "600";

        btn.addEventListener("click", () => {
          clearInactivityTimer();
          stopAudio();
          sequenceIndex += 1;
          advanceSequence();
        });

        return btn;
      }

      // SEQUENCE CONTROL - ADVANCE TO NEXT STEP
      function advanceSequence() {
        if (sequenceIndex >= sequence.length) {
          finishTour();
          return;
        }
        const segment = sequence[sequenceIndex];
        if (segment.type === "MOVE") {
          launchMove(segment);
        } else {
          launchNarration(segment);
        }
      }

      // TOUR CONTROL - FINISH HANDLER
      function finishTour() {
        clearInactivityTimer();
        stopAudio();
        currentState = State.IDLE;
        activeMove = null;
        focusTarget = null;
        sessionId = null;
        startButton.disabled = false;
        startButton.textContent = "Rejouer la visite guid√©e";
        setStatus("Visite termin√©e. Musia attend vos prochaines questions.", "success");
        setTimeout(hideNarration, 3000);
      }

      // TOUR CONTROL - RESET HANDLER
      function resetTour() {
        stopAudio();
        clearInactivityTimer();
        sequenceIndex = 0;
        activeMove = null;
        currentState = State.IDLE;
        focusTarget = null;
        currentArtwork = null;
        sessionId = null;
        uProgress = stops[0].u;
        setRobotPose(uProgress, false);
        setNarration("En attente du lancement de la visite.");
        setStatus("Musia est pr√™t pour la visite.");
        setTimeout(hideNarration, 2000);
      }

      resetTour();

      // EVENT LISTENERS - START BUTTON
      startButton.addEventListener("click", async () => {
        if (currentState !== State.IDLE) return;

        startButton.disabled = true;
        startButton.textContent = "Visite en cours‚Ä¶";
        setStatus("Connexion au serveur IA...");

        // Initialize conversation session
        await startConversation();

        setStatus("Musia initialise la trajectoire...");
        sequenceIndex = 0;
        setTimeout(() => advanceSequence(), 800);
      });

      // ANIMATION LOOP - UPDATE LOGIC
      let lastTime = 0;

      function update(deltaTime) {
        if (!activeMove) return;

        activeMove.timeElapsed += deltaTime;
        const ratio = activeMove.timeElapsed / activeMove.duration;
        const uRange = activeMove.endU - activeMove.startU;
        let newU = activeMove.startU + uRange * ratio;

        if (ratio >= 1.0) {
          newU = activeMove.endU;
          setRobotPose(newU);
          activeMove = null;
          sequenceIndex += 1;
          setTimeout(() => advanceSequence(), 600);
        } else {
          uProgress = THREE.MathUtils.clamp(newU, 0, 1);
          setRobotPose(uProgress);
        }
      }

      // EVENT LISTENERS - WINDOW RESIZE
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener("resize", onWindowResize);

      // ANIMATION LOOP - MAIN RENDER LOOP
      function renderLoop(time) {
        requestAnimationFrame(renderLoop);
        const delta = lastTime ? Math.min((time - lastTime) / 1000, 0.1) : 0;
        lastTime = time;

        update(delta);
        updateCamera();
        renderer.render(scene, camera);
      }

      requestAnimationFrame(renderLoop);

      // Check backend connection on load
      (async () => {
        try {
          const response = await fetch(`${API_BASE_URL}/health`);
          if (response.ok) {
            console.log("‚úÖ Backend NLP connect√©");
            setStatus("Musia est pr√™t (Backend IA connect√©)", "success");
          }
        } catch (error) {
          console.warn("‚ö†Ô∏è Backend NLP non disponible");
          setStatus("‚ö†Ô∏è Backend IA non disponible (mode local)", "error");
        }
      })();
    </script>
  </body>
</html>
